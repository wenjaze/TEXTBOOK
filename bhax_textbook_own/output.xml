<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Univerzális programozás</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Így neveld a programozód!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <author>
        <personname>
            <honorific>Dr</honorific>
            <surname>Bátfai</surname>
            <firstname>Norbert</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>E. adjunktus, DE.</shortaffil>
            <jobtitle>Egyetemi adjunktus</jobtitle>
            <orgname>Debreceni Egyetem</orgname>
            <orgdiv>Információtechnológiai Tanszék</orgdiv>
            <address>
                <email>batfai.norbert@inf.unideb.hu</email>
                <email>nbatfai@gmail.com</email>
            </address>
        </affiliation>
        <address>
            <street>Kassai út 26.</street>
            <city>Debrecen</city>
            <postcode>4028</postcode>
            <country>Magyarország</country>
            <email>batfai.norbert@inf.unideb.hu</email>
            <otheraddr>
                <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/">https://arato.inf.unideb.hu/batfai.norbert/</link>
            </otheraddr>
        </address>
    </author>   
    <author>
        <personname>       
            <surname>Bátfai</surname>
            <firstname>Mátyás</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>tanuló</shortaffil>
            <jobtitle>tanuló</jobtitle>
            <orgname>Debreceni Hunyadi János Általános Iskola</orgname>
            <orgdiv>6/c</orgdiv>
            <address>
                <email>batfai.matyi@gmail.com</email>               
            </address>
        </affiliation>               
    </author>  
    
    <author>
        <personname>       
            <surname>Bátfai</surname>
            <firstname>Nándor</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>tanuló</shortaffil>
            <jobtitle>tanuló</jobtitle>
            <orgname>Debreceni Hunyadi János Általános Iskola</orgname>
            <orgdiv>4/c</orgdiv>
            <address>
                <email>batfai.nandi@gmail.com</email>               
            </address>
        </affiliation>               
    </author>  
    
    <author>
        <personname>       
            <surname>Bátfai</surname>
            <firstname>Margaréta</firstname>        
        </personname>    
        <affiliation>
            <shortaffil>tanuló</shortaffil>
            <jobtitle>tanuló</jobtitle>
            <orgname>Debreceni Hunyadi János Általános Iskola</orgname>
            <orgdiv>4/c</orgdiv>
            <address>
                <email>batfai.greta@gmail.com</email>               
            </address>
        </affiliation>               
    </author>  
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2020. március 22, v. 0.0.7</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, 2020, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
        <para>
        A tananyag elkészítését az EFOP-3.4.3-16-2016-00021 számú projekt támogatta. A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszírozásával valósult meg.
        </para>        
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            A Brun tételes feladat kidolgozása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.5</revnumber>
        <date>2020-03-02</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az Chomsky/a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> 
            és Caesar/EXOR csokor feladatok kiírásának aktualizálása (a heti előadás és laborgyakorlatok támogatására).
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.6</revnumber>
        <date>2020-03-21</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            A MALMÖ projektes feladatok átvezetése, minden csokor utolsó feladata Minecraft ágensprogramozás ezzel. Mottók aktualizálása.
            Prog1 feladatok aktuzalizálása. Javasolt (soft skill) filmek, elméletek, könyvek, előadások be.
        </revremark>
    </revision>
        <revision>
        <revnumber>0.0.7</revnumber>
        <date>2020-03-22</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Javítások.
        </revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
<blockquote>
    <attribution>Marx György, <citetitle>Magyar Tudomány, 1987 (27) 12.</citetitle>, <citation>MARX</citation></attribution>
    <para>
        „Csak kicsi hatást ért el a videójáték-ellenes kampány. A legtöbb iskolában kétműszakos üzemben dolgoznak a számítógépek, értő
        és áldozatos tanárok ellenőrzése mellett.”
    </para>
    <para>
        „Minden számítógép-pedagógus tudja a világon, hogy játékokkal kell kezdeni. A játékot követi a játékprogramok írása, majd a 
        tananyag egyes részeinek a feldolgozása.„
    </para>
</blockquote>
<blockquote>
    <attribution>Eric S. Raymond, <citetitle>How To Become A Hacker, 2001.</citetitle>,
    <link xlink:href="http://www.catb.org/~esr/faqs/hacker-howto.html">http://www.catb.org/~esr/faqs/hacker-howto.html</link></attribution>
    <para>
        „I can't give complete instructions on how to learn to program here — it's a complex skill. But I can tell you that books and courses won't do it — many, maybe most of the best hackers are self-taught. You can learn language features — bits of knowledge — from books, but the mind-set that makes that knowledge into living skill can be learned only by practice and apprenticeship. What will do it is (a) reading code and (b) writing code.”
    </para>
</blockquote>
<blockquote>
    <attribution>John Carmack, <citetitle>Facebook post, 2019.</citetitle>,
    <link xlink:href="https://www.facebook.com/permalink.php?story_fbid=2547632585471243&amp;id=100006735798590">in his private Facebook post</link></attribution>
    <para>
        „I’m going to work on artificial general intelligence (AGI).”
    </para>
    <para>
        I think it is possible, enormously valuable, and that I have a non-negligible chance of making a difference there, so by a Pascal’s Mugging sort of logic, I should be working on it.
    </para>
    <para>
        For the time being at least, I am going to be going about it “Victorian Gentleman Scientist” style, pursuing my inquiries from home, and drafting my son into the work.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám felhasználjuk az egyetemi programozás oktatásban is: a reguláris programozás képzésben minden
            hallgató otthon elvégzendő labormérési jegyzőkönyvként, vagy kollokviumi jegymegajánló 
            dolgozatként írja meg a saját változatát belőle. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
            <title>Mi a programozás?</title>
            <para>
                Ne cifrázzuk: programok írása. Mik akkor a programok? Mit jelent az írásuk?
            </para>
            <para>
                Magam is ezeken gondolkozok. Szerintem a programozás lesz a jegyünk egy másik világba...,  
                hogy a galaxisunk közepén lévő fekete lyuk eseményhorizontjának felületével ez milyen relációban van, ha 
                egyáltalán, hát az homályos...
            </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Kezd ezzel: <link xlink:href="http://esr.fsf.hu/hacker-howto.html">http://esr.fsf.hu/hacker-howto.html</link>!</para>                        
                </listitem>
                <listitem>
                    <para>Olvasgasd aztán a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para>C kapcsán a <citation>KERNIGHANRITCHIE</citation> könyv adott részei.</para>                        
                </listitem>
                <listitem>
                    <para>C++ kapcsán a <citation>BMECPP</citation> könyv adott részei.</para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Amiből viszont a legeslegjobban lehet tanulni, az a 
                        <link xlink:href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html">The GNU C Reference Manual</link>, mert gcc specifikus és programozókra
                        van hangolva: szinte csak 1-2 lényegi mondat és apró, lényegi kódcsipetek! Aki pdf-ben jobban
                        szereti olvasni: <link xlink:href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.pdf"/>
                    </para>                        
                </listitem>
                <listitem>
                    <para>Az R kódok olvasása kis általános tapasztalat után automatikusan, erőfeszítés nélkül menni fog. 
                        A Python nincs ennyire a spektrum magától értetődő végén, ezért ahhoz olvasd el a  
                        <citation>BMEPY</citation> könyv 25-49, kb. 20 oldalas gyorstalpaló részét.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket, előadásokat nézzek meg, könyveket olvassak el?</title>
            <para>
                A kurzus kultúrájának élvezéséhez érdekes lehet a következő elméletek megismerése, könyvek elolvasása,
                filmek megnézése.
            </para>
            <para>
                Elméletek.
            </para>            
            <itemizedlist>
                <listitem>
                    <para>
                        Einstein: A speciális relativítás elmélete.
                    </para>                        
                </listitem>
                <listitem>
                    <para>
                        Schrödinger: Mi az élet?
                    </para>                        
                </listitem>
                <listitem>
                    <para>
                        Penrose-Hameroff: Orchestrated objective reduction.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Julian Jaynes: Breakdown of the Bicameral Mind.
                    </para>                        
                </listitem>
            </itemizedlist>
            <para>
                Könyvek.
            </para>            
            <itemizedlist>
                <listitem>
                    <para>
                        Carl Sagan, Kapcsolat.
                    </para>                        
                </listitem>
                <listitem>
                    <para>
                        Roger Penrose, A császár új elméje.
                    </para>                        
                </listitem>
                <listitem>
                    <para>
                        Asimov: Én, a robot.
                    </para>                        
                </listitem>
                <listitem>
                    <para>
                        Arthur C. Clarke: A gyermekkor vége.
                    </para>                        
                </listitem>
            </itemizedlist>                        
            <para>
                Előadások.
            </para>            
            <itemizedlist>
                <listitem>
                    <para>
                        Mariano Sigman: Your words may predict your future mental health, 
                        <link xlink:href="https://youtu.be/uTL9tm7S1Io">https://youtu.be/uTL9tm7S1Io</link>,
                        hihetetlen, de Julian Jaynes kétkamarás tudat elméletének legjobb bizonyítéka információtechnológiai...
                    </para>                        
                </listitem>
                <listitem>
                    <para>
                        Daphne Bavelier: Your brain on video games, 
                        <link xlink:href="https://youtu.be/FktsFcooIG8">https://youtu.be/FktsFcooIG8</link>,
                        az esporttal kapcsolatos sztereotípiák eloszlatására (
                        „The video game players of tomorrow are older adults”: 0.40-1:20,
                        „It is not true that Screen time make your eyesight worse”: 5:02).
                    </para>                        
                </listitem>
            </itemizedlist>            
            <para>
                Filmek.
            </para>            
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Rain Man, 
                        <link xlink:href="https://www.imdb.com/title/tt0095953/">https://www.imdb.com/title/tt0095953/</link>,
                        az <citation>SMNIST</citation> munkát ihlette, melyeket akár az 
                        <link xlink:href="#bhax-textbook-feladatok-schwarzenegger">MNIST</link>-ek helyett lehet csinálni.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Kódjátszma, 
                        <link xlink:href="https://www.imdb.com/title/tt2084970">https://www.imdb.com/title/tt2084970</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-caesar.EXOR-toro">kódtörő feladat</link> élménye.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Interstellar, 
                        <link xlink:href="https://www.imdb.com/title/tt0816692">https://www.imdb.com/title/tt0816692</link>.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Middle Men, 
                        <link xlink:href="https://www.imdb.com/title/tt1251757/">https://www.imdb.com/title/tt1251757/</link>, mitől 
                        fejlődött az internetes fizetés?
                    </para>                        
                </listitem>
                <listitem>
                    <para>Pixels, 
                        <link xlink:href="https://www.imdb.com/title/tt2120120/">https://www.imdb.com/title/tt2120120/</link>, mitől
                        fejlődött a PC?
                    </para>                        
                </listitem>
                <listitem>
                    <para>Gattaca, 
                        <link xlink:href="https://www.imdb.com/title/tt0119177/">https://www.imdb.com/title/tt0119177/</link>.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Snowden, 
                        <link xlink:href="https://www.imdb.com/title/tt3774114/">https://www.imdb.com/title/tt3774114/</link>.
                    </para>                        
                </listitem>
                <listitem>
                    <para>The Social Network, 
                        <link xlink:href="https://www.imdb.com/title/tt1285016/">https://www.imdb.com/title/tt1285016/</link>.
                    </para>                        
                </listitem>
                <listitem>
                    <para>The Last Starfighter, 
                        <link xlink:href="https://www.imdb.com/title/tt0087597/">https://www.imdb.com/title/tt0087597/</link>.
                    </para>                        
                </listitem>
                <listitem>
                    <para>What the #$*! Do We (K)now!?,, 
                        <link xlink:href="https://www.imdb.com/title/tt0399877/">https://www.imdb.com/title/tt0399877/</link>.
                    </para>                        
                </listitem>
                <listitem>
                    <para>I, Robot, 
                        <link xlink:href="https://www.imdb.com/title/tt0343818">https://www.imdb.com/title/tt0343818</link>.
                    </para>                        
                </listitem>
            </itemizedlist> 
            <para>
                Sorozatok.
            </para>            
            <itemizedlist>
                <listitem>
                    <para>Childhood's End, 
                        <link xlink:href="https://www.imdb.com/title/tt4171822/">https://www.imdb.com/title/tt4171822/</link>.
                    </para>                        
                </listitem>                
                <listitem>
                    <para>Westworld, 
                        <link xlink:href="https://www.imdb.com/title/tt0475784/">https://www.imdb.com/title/tt0475784/</link>, 
                         Ford az első évad 3. részében konkrétan meg is nevezi Julian Jaynes kétkamarás tudat elméletét, mint a 
                        hosztok programozásának alapját...
                    </para>                        
                </listitem>                
                <listitem>
                    <para>Chernobyl, 
                        <link xlink:href="https://www.imdb.com/title/tt7366338/">https://www.imdb.com/title/tt7366338/</link>.
                    </para>                        
                </listitem>                
                <listitem>
                    <para>Stargate Universe, 
                        <link xlink:href="https://www.imdb.com/title/tt1286039">https://www.imdb.com/title/tt1286039</link>, a
                        Desteny célja a mikrohullámú háttér struktúrája mögötti rejtély feltárása...
                    </para>                        
                </listitem>                
                <listitem>
                    <para>The 100, 
                        <link xlink:href="https://www.imdb.com/title/tt2661044/">https://www.imdb.com/title/tt2661044/</link>.
                    </para>                        
                </listitem>  
                <listitem>
                    <para>Genius, 
                        <link xlink:href="https://www.imdb.com/title/tt5673782">https://www.imdb.com/title/tt5673782</link>.
                    </para>                        
                </listitem> 
            </itemizedlist>             
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: Végtelen ciklus-t 2 féle képpen szokás írni 
        </para>
        <para>
            - while ciklussal :
        </para>
            <programlisting language="c"><![CDATA[int main()
{
    while(1)
    {

    }
}]]></programlisting> 
        <para>
            - for ciklussal :
        </para>
        <programlisting language="c"><![CDATA[int main()
{       
    for(;;)
    {

    }
}]]></programlisting>
        <para>
        Ha ezt futtatjuk 100%-on megy a processzor,
        viszont ha a gcc-be beépített OpenMP-s headert (omp.h) include-olva
        </para>
        <programlisting language="c"><![CDATA[
    #include <omp.h>

]]></programlisting>
        <para>
        párhuzamosan futtathatjuk végtelen ciklusunkat.
        A következő a párhuzamos futtatás szintaktikája :
        </para>
        <programlisting language="c"><![CDATA[
    #pragma omp parallel
    {
        ide jön a fent megírt végtelen ciklus;
    }

]]></programlisting>
        <para>
        A feladat teljes forráskódja : 
        </para>
        <programlisting language="c"><![CDATA[
    #include <unistd.h>
    #include <omp.h>

    int main()
    {
        #pragma omp parallel
        {
        while(1);
        }
        return 0;
    }
]]></programlisting>
        
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>
        Fontos, hogy az fopen-t használva a fordítás "vegtelen.c" fájlnév esetén : gcc vegtelen.c -fopenmp -o vegtelen
        </para>
        <para>
        Megyjegyzés : "g++ vegtelen.c -fopenmp -o vegtelen"-t használva nem kell include-olni a omp.h headert.
        </para>       
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

    boolean Lefagy(Program P)
    {
         if(P-ben van végtelen ciklus)
            return true;
         else
            return false; 
    }

    main(Input Q)
    {
        Lefagy(Q)
    }
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

    boolean Lefagy(Program P)
    {
         if(P-ben van végtelen ciklus)
            return true;
         else
            return false; 
    }

    boolean Lefagy2(Program P)
    {
         if(Lefagy(P))
            return true;
         else
            for(;;); 
    }

    main(Input Q)
    {
        Lefagy2(Q)
    }

}]]></programlisting>                       
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            használata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            &#13;Két változó értékét megcserélni nem lenne nehéz,
            &#13;swap függvény, segédváltozó, exor, stb. 
            &#13;Mi kell ahoz, hogy mindezek nélkül cseréljük meg az értéküket?
            &#13;- Valamilyen művelet aminek van ellentétje pl : osztás/szorzás összeadás/kivonás
            &#13;- 2 változó deklaráva
            &#13;- csere függvényben meghívva
            &#13;Csere függvény :
        </para>
        <programlisting language="c"><![CDATA[

    void csere(int *a,int *b)
    {
        printf("a = %d\nb = %d\n",*a,*b);
        *a = *a + *b; //a(17) = 12 + 5 
        *b = *a - *b; //b(12) = 17 - 5
        *a = *a - *b; //a(5) = 17 - 12
        printf("\na = %d\nb = %d\n", *a,*b);
    } 


]]></programlisting>
        <para>
            &#13;- Bekéri két változó memóriacímét : a,b.
            &#13;- Kiírja a két változó nevét, majd az értéküket.
            &#13;- Felcseréli őket összeadás/kivonás használatával.
            &#13;- Kiírja a megcserélt változók értékeit.
        </para>
<programlisting language="c"><![CDATA[
    #include <stdio.h>
    
    void csere(int*,int*);

    int main(){

    int a = 5;
    int b = 12;

    csere(&a,&b);

    return 0;
    }

    void csere(int *a,int *b)
    {
        printf("a = %d\nb = %d\n",*a,*b);
        *a = *a + *b; //a(17) = 12 + 5 
        *b = *a - *b; //b(12) = 17 - 5
        *a = *a - *b; //a(5) = 17 - 12
        printf("\na = %d\nb = %d\n", *a,*b);
    } 


]]></programlisting>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása: 
            Iffel nem nehéz, csak feltételt kell írnunk arra, hogy amikor a "labda" eléri a széleket
            visszapattanjon.
            Labdapattogtatás if-el:
        </para>
            <programlisting language="c"><![CDATA[
#include <unistd.h>
#include <stdlib.h>
#include <curses.h>
#include <stdio.h>

int
main ( void )
{
    WINDOW *ablak;
    ablak = initscr ();
    // noecho();
    // cbreak();
    // nodelay (ablak,true);

    int x = 0;
    int y = 0;

    int deltax = 1;
    int deltay = 1;

    int keretx = 0;
    int kerety = 0;

    for ( ;; ) 
    {

        getmaxyx( ablak, kerety,keretx);
        mvprintw ( y, x, "x:%dy:%d",x,y );
        refresh ();
        usleep ( 50000 );
        clear();

        x = x + deltax;
        y = y + deltay;

        if (x >= keretx - 1)
        {
            deltax = deltax * - 1;
        }
        if (y >= kerety - 1)
        {
            deltay = deltay * - 1;
        }
        if  (y <= 0)
        {
            deltay = deltay * -1;
        }
        if (x <= 0)
        {
            deltax = deltax * -1;
        }

        
            
    }

    return 0;
}

]]></programlisting>
        <para>
        If nélküli verzióhoz nagyjából az az ötlet, hogy csinálunk két <type>int</type> tömböt.
        Mind a két tömböt feltöltjük, 1-el (feltolt függvény), KIVÉVE azon koordináták helyére nem írunk 1-et,
        amelyek a szélén vannak. (pl.: adott egy 80x30-as ablakunk, akkor az 1. és 79. valamint az 1. és a 29.
        helyre -1et írunk). Ez azért kell mert minden egyes "lépésnél" (lépés : egyszer lefut ami a for ciklusban van)
        azért mozog a "labda" mert 1-el növeljük az értékét mind a 2 tengyelyen. Azzal, hogy feltöltöttük a két tömböt,
        -1 illetve 1-ekkel azért válik hasznunkra mert minden egyes "lépés"-nél megszorozzunk az adott koordináta 1, vagy -1-es
        értékével, ami azt eredményezi, hogy visszafele fog elindulni a labdánk amikor a széleihez ér.
        Labdapattogtatás if nélkül :
    </para>
        <programlisting language="c"><![CDATA[
#include <unistd.h>
#include <stdlib.h>
#include <curses.h>
#include <stdio.h>

//tombok feltoltése irányokkal (1,-1)
// az irányok értéke mindenhol 1, kivéve az első és az utolsó előtti pontot ahol -1.
void feltolt(int tomb[],int max)
{
    for(int i=1; i<max; i++)
    {
        tomb[i]=1;
    } 
    tomb[1]=-1; 
    tomb[max-1]=-1;
}

int main(){

    //új ablak 
    WINDOW  *ablak;
    ablak = initscr();

    noecho();
    cbreak();
    nodelay (ablak,true);
    
    int mx = 0; //az ablak szélessége.
    int my = 0; //az ablak magassága.

    int x = 1;  //y kezdő koordinátája.
    int y = 1;  //y kezdő koordinátája.

    getmaxyx(ablak,my,mx);
    
    //mx = mx/2;//fele szélesség.
    //my = my/2;//fele magasság.

    int irany_x[mx];
    int irany_y[my];

    feltolt(irany_y,my);
    feltolt(irany_x,mx);

    // x és y mozgási sebessége/iránya.
    int deltax = 1;
    int deltay = 1;

    for (;;) //busy_loop
    {
        // x koordináta növelése 1-el.
        x += deltax;
        // y koordináta növelése 1-el.
        y += deltay;

        // x mozgási irányának beállítása.
        deltax *= irany_x[x];
        // y mozgási irányának beállítása.
        deltay *= irany_y[y]; 
        
        refresh(); 
        clear(); // előzőleg rajzolt "labdák" törlése.
        usleep(50000); // a "labda" sebessége.(minél kisebb annál gyorsabb).
        mvprintw(y ,x,"x:%dy:%d",x,y); // kiírja az aktuális koordinátákat.
            
    }

    return 0;
}

]]></programlisting>

    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Linus Torvalds a Linux atyja által kitalált BogoMipsel a régi Linux disztrók
            bootolása közben találkozhattunk, valami hasonló képpen:
        </para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="files/bogomips.png"/>
                </imageobject>
            </mediaobject>
        <para>
            A kód ami ezt eredményezte, a BogoMips mely arra szolgál
            , hogy a processzorunk gyorsaságát lemérje.
            Ha kicsit jobban belenézünk a kódba láthatjuk hogyan is működik.
            A <emphasis>loops_per_sec</emphasis>-et 1-re állítva, a for ciklus ciklusfejében,
            shiftelgetjük egy-el mindig. Tehát a <emphasis>loops_per_sec</emphasis> értékei a
            2 hatványai lesznek lesznek : 

            &#13;1
            &#13;2
            &#13;4
            &#13;8
            &#13;16
            &#13;32
            &#13;64
            &#13;128
            &#13;...

            &#13;Ami binárisan történni fog a <emphasis>loops_per_sec</emphasis>-el:
            &#13;00000001
            &#13;00000010
            &#13;00000100
            &#13;00001000
            &#13;00010000
            &#13;00100000
            &#13;01000000
            &#13;10000000
        </para>
        <para>
            Ez arra lesz jó hogy a delay() függvényünk - amely azt csinálja, hogy 0tól elmegy a
            paraméterként bekért értékig - betudja kérni paraméterként.
            Ahogy belépünk a while ciklusba egy szintén unsigned long long int típusú <emphasis>ticks</emphasis>-be
            tároljuk a clock() értékét mely egy bizonyos tickszám amennyit a processzor tick-el egy adott idő alatt.
            Majd meghívjuk a delay függvényünket paraméterként a <emphasis>loops_per_sec</emphasis>-et átadva.
            Ezután ugyanugy a ticksben eltároljuk az eddig eltelt tickset a mostani clock() értékéből.
            Ezáltan megkapjuk a 0-<emphasis>loops_per_sec</emphasis>-ig elszámolás idejét.
        </para>
        <para>
            Innentől már csak osztás/szorzás, hogy egy olvasható/mérhető értéket kapjunk.
        </para>
        <para>
            Átvéve a forrás ciklusfejét hasonlóan használhatjuk számolásra is.
            Pl. egy szó hosszának megszámolására hasonló képpen : 
        </para>

        
        <programlisting language="c"><![CDATA[
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SZO 10

int
main (int argc,char** argv)
{
    char szo[10];

    int hossz = strlen(argv[1]);
    int szamlalo = 0;
    int bitek_szama = 0;

    unsigned long long int loops_per_sec = 1;

    while (loops_per_sec <<= 1)
    {
        
        if (loops_per_sec % 8 == 0)
        {
            bitek_szama = hossz * 8;
            szamlalo++;
            if (szamlalo == hossz)
            {
                printf("szo hossza : %d karakter.\nszo merete : %d bit.\n",hossz,bitek_szama);
                return 0;
            }
        }
        
    }
    

    // while(szoInt >>= 1)
    // {
    //  printf("szo:%s\tszoInt:%d\n",szo,szoInt);
    // }

    return 0;

}

]]></programlisting>

    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/wenjaze/Bhax-Textbook-Feladatok/blob/master/Turing/pagerank/pr.c">PageRank.cpp</link>

            Az alábbi program a Google első, alap algoritmusának, egy 4 lapból álló
            weblaphálózat PageRank értékének kiszámolására szolgáló C++ implementációja.

            A PageRank algoritmust Larry Page és Sergey Brin feljesztette ki 1998-ban.
            Ez lehetővé teszi számunkra (és a Google számára) hogy meghatározza, egy lap mennyire "jó"
            a többi laphoz képest. 

            Mindezt a rá mutató lapok száma és a rámutató lapok számának PageRank értéke befolyásolja.
            Jelenlegi 4 lapból álló hálózatunkra alkalmazva az fentieket, gyakorlatilag egy mátrix szorzást
            kell elvégeznünk, majd az értékeket addig finomítani, míg meg nem közelítik az előzőleg megadott értéket,
            a pontosság érdekében.

        </para>
        <programlisting language="c++"><![CDATA[
#include <iostream>
#include <math.h>


void ki (double tomb[], int db)
{
    int i;
    for (i=0; i<db; i++)
    {
        std::cout<<"PageRank [" << i << "] : " << tomb[i] << std::endl;
    }
}

double tavolsag(double PR[],double PR_v[],int db)
{
    double osszeg = 0.0;
    int i;
    for(i=0;i<db;i++)
    {
        osszeg+=abs(PR[i] - PR_v[i]);
    }   
    return osszeg;
}

int main(void){

double L[4][4] = {
    {0.0, 0.0, 1.0 / 3.0, 0.0},
    {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
    {0.0, 1.0 / 2.0, 0.0, 0.0},
    {0.0, 0.0, 1.0 / 3.0, 0.0}
};

double PR[4] = {0.0, 0.0, 0.0, 0.0};
double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};
long int i=0,j=0;

    for (;;)
    {
        for(int i = 0; i < 4;++i)
        {
            PR[i] = 0.0;
            for(int j = 0;j<4;++j)
            {
                PR[i] += (L[i][j]*PRv[j]);
            }
        }
        
        if (tavolsag(PR,PRv, 4) < 0.0000001)
        break;
    
        for(i=0;i<4;++i)
        {
            PRv[i]  = PR[i];
        }
    }
    
    ki (PR,4);
    return 0;
}]]>


</programlisting>
<para>
Ugyanez vektorokkal.
</para>
<programlisting language="c++"><![CDATA[
#include <iostream>
#include <math.h>
#include <vector>
#include <iterator>

using namespace std;

void ki (vector<double> tomb)
{
    vector<double>::iterator it;
    for (it = tomb.begin(); it != tomb.end(); it++)
    {
        cout<<"PageRank ["<< distance(tomb.begin(),it)<<"] : " << *it << endl;
    }
}

double 
tavolsag(vector<double> PR,vector<double> PR_v)
{
    vector<double>::iterator pri = PR.begin();
    vector<double>::iterator prvi = PR_v.begin();

    double tav = 0.0;
    for(pri = PR.begin();pri != PR.end();pri++)
    {
        tav += abs((*pri) - (*prvi));
        prvi++;
    }   
    return tav;
}

int main(void){

vector<vector<double>> L= {
    {0.0, 0.0, 1.0 / 3.0, 0.0},
    {1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
    {0.0, 1.0 / 2.0, 0.0, 0.0},
    {0.0, 0.0, 1.0 / 3.0, 0.0}
};

vector<vector<double>>::iterator sor;
vector<double>::iterator oszlop;
vector<double>::iterator Pi;
vector<double>::iterator PvI;


vector<double> PR;
    for(int i = 0;i < 4;i++)
        PR.push_back(0.0);
vector<double> PRv;
    for(int i = 0;i < 4;i++)
        PRv.push_back(1.0 / 4.0);


    // vector<double> PR = {0.0, 0.0, 0.0, 0.0};
    // vector<double> PRv = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};

    for (;;)
    {
        PR = PRv;

    for(int i=0; i<PR.size(); i++) 
    {
            double temp = 0.0;

            for(int j=0; j<PRv.size(); j++) 
            {
                temp += L[i][j] * PR[j];
                PRv[i] = temp;
            }
    } 

    if (tavolsag(PR,PRv) < 0.000001)
        break;
    }
    
    ki(PR);
    return 0;
}


}]]>
</programlisting>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                        
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            A Monty Hall probléma szemléltetése a következő:
            - Adott 3 ajtó.
            - 2 ajtó mögött egy-egy kecske van, a harmadik mögött pedig egy új autó.
            - Választunk egy ajtót, ekkor egy a három közül, ami nem a választott és nem amelyik mögött az autó van kinyílik.
            - Ilyenkor élhetünk azzal a lehetőséggel, hogy válasszunk a 2 fennmaradó ajtó közül.
            - A kérdés, hogy megváltoztatjuk az válaszott ajtót, vagy maradunk az eredetinél.

            A helyes válasz minden esetben a változtatás.
            Ha választunk egy ajtót, annak 1/3-ad esélye van a nyerésre, a maradéknak 2/3.
            Miután kinyílik az az ajtó amelyik mögött nem az autó van, annak az esélye, hogy a "nem válaszottt"
            másik ajtó mögött az autó van, ugyanúgy 2/3 lesz.

            Monty Hall probléma szimulációja R-ben : 
        </para>
                <programlisting language="R"><![CDATA[
#   An illustration written in R for the Monty Hall Problem 
#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

kiserletek_szama=10000000
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)
musorvezeto=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }

    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

}

nemvaltoztatesnyer= which(kiserlet==jatekos)
valtoztat=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
}

valtoztatesnyer = which(kiserlet==valtoztat)


sprintf("Kiserletek szama: %i", kiserletek_szama)
length(nemvaltoztatesnyer)
length(valtoztatesnyer)
length(nemvaltoztatesnyer)/length(valtoztatesnyer)
length(nemvaltoztatesnyer)+length(valtoztatesnyer)

]]></programlisting>
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/> 
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: 

            Az Unáris talán a legegyszerűbb számrendszer. Annyi '|' -t tartalmaz 
            amennyi a szám decimálisan ötösével elszeparálva. Az alábbi program
            bekér egy számot decimális formában, amit egy egész változóban tárol,
            majd ezt kiírja unárisan.

            <programlisting language="c"><![CDATA[
        #include <stdio.h>

        int
        main()
        {
            int decimal = 0;
            scanf("%d",&decimal);
            decimal++;
            for(int i =1;i<decimal;i++)
            {
                printf("|");
                if (i %5 == 0)
                {
                    printf(" ");
                }
            }
            return 0;
        }
]]>
     </programlisting>

     <screen>
<![CDATA[$ ./unary
14
||||| ||||| ||||
]]>
        </screen>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
            <para>
                    &#13;Változók ∈ <emphasis>X, Y, Z</emphasis>.
                    &#13;Konstansok ∈ <emphasis>a, b, c</emphasis>.
            </para>
                <orderedlist numeration="arabic">   
                    <listitem>
                        <para>
                        &#13;X -&gt; aXYZ 
                        &#13;aX -&gt; aa aaYZ
                        &#13;Y -&gt; bb aabb
                        &#13;c -&gt; Z aaYZ
                        &#13;Z -&gt; ccc aaYccc
                        &#13;aaY -&gt; aaabbb aaabbbccc
                        </para>
                    </listitem>

                    <listitem>
                        <para>
                        &#13;aXbc  -&gt; abXc 
                        &#13;ab -&gt; aaa aaaXc
                        &#13;X -&gt; bYc aaabYc
                        &#13;bYc -&gt; bcY aaabcY
                        &#13;Y  -&gt; c aaabcc
                        &#13;bcc -&gt; bbbccY aaabbbccY
                        &#13;Y -&gt; c aaabbbccc 
                        </para>
                    </listitem>
                </orderedlist>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            A legegyszerűbb példa olyan kódcsipetre, amely a c89-es szabvánnyal nem fordul le, a c99-essel pedig igen
            az nem más mint egy egyszerű for ciklusbeli deklaráció, valamint a "//" kommentelés. A for ciklust akkor szoktuk használni amikor pontosan tudjuk (többnyire),
            hogy mettől meddig akarunk egy bizonyos műveletet elvégezni. pl: írassuk ki a számok négyzetét 1-10-ig:
        </para>
            <programlisting language="C">
                <![CDATA[
#include <stdio.h>

int main()
{
    for(int i = 1;i<=10;i++) printf("%d\n",i*i );
    //ez egy komment lenne
    return 0;
}
                ]]>
            </programlisting>
            <para>
                Ha a fenti kódcsipetet futtatjuk <emphasis>-std=c89</emphasis> prefixel,
                a következő hibaüzeneteket kapjuk.
            </para>
            <screen>
                <![CDATA[
gcc temp.c -o temp -std=c89
temp.c: In function ‘main’:
temp.c:5:2: error: ‘for’ loop initial declarations are only allowed in C99 or C11 mode
  for(int i = 1;i<=10;i++) printf("%d\n",i*i );
  ^~~
temp.c:5:2: note: use option -std=c99, -std=gnu99, -std=c11 or -std=gnu11 to compile your code
temp.c:6:2: error: C++ style comments are not allowed in ISO C90
  //ez egy komment lenne
  ^
temp.c:6:2: error: (this will be reported only once per input file)

                    ]]>
            </screen>
            <para>
                <orderedlist numeration="arabic">
                    <listitem>
                        <para>
                        &#13;Probléma :
                        &#13;A for ciklusfejben nem engedélyezett a deklaráció, csak az értékadás.
                        </para> 
                    </listitem>
                    <listitem>
                        <para>
                        &#13;Probléma :
                        &#13;A c89-es szabvány még nem tolerálja a "//" kommentet csak a "/*   */" típusút.
                        </para> 
                    </listitem>

                </orderedlist>

                </para>

            <para>
                <emphasis>C89-ES SZABVÁNYNAK MEGFELELŐ KÓD, UGYANAHHOZ A KÓDCSIPETHEZ:</emphasis>
            </para>
            <programlisting language="C">
                <![CDATA[
#include <stdio.h>

int main()
{
    int i;
    for(i = 1;i<=10;i++) printf("%d\n",i*i );
    /* ez egy komment lenne */
    return 0;
}
                ]]>
            </programlisting>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Ilyen féle feladatokhoz, amikor egy bemenetről, részletes "lexikai" elemzést akarunk
            készíteni, majd esetlegesen kiválogatni valamit, remekül alkalmazható a LeXer.
            &#13;Lexer a következőt csinálja :
            &#13;- A standard inputról érkező szimbólum sorozatokat, átkonvertálja tokenekké,
            amik valójában bizonyos stringek, különbözően azonosítva.
            Jelen esetben a lexxert a folyamatos bementről érkező szimbólumokat tokenizálja,
            majd kiselejtezi azokat, melynek racinális szám formája van.
        
        <programlisting><![CDATA[
%{
#include <stdio.h>
int realnumbers = 0;
%}
digit   [0-9]
%%
{digit}*(\.{digit}+)?   {++realnumbers; 
    printf("[ felismert valos szam = %s %f ]\n", yytext, atof(yytext));}
%%
int
main ()
{
 yylex ();
 printf("The number of real numbers is %d\n", realnumbers);
 return 0;
}
]]>
</programlisting>
</para>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            <link xlink:href="https://github.com/wenjaze/Bhax-Textbook-Feladatok/blob/master/Chomsky/1337/leet.l">1337.l</link> 
            A 1337 vagy leet cipher, egy úgymond számítógépes nyelv.
            Leggyakrabb előfordulása, ahol én találkoztam vele azok az online/multiplayer
            játékok. Gyakori, hogy valaki vagy csak poénból, vagy mert "hacker"-nek érzi magát.
            &#13;A legérdekesebb előfordulása azonban a <emphasis>DEAD COW CULT</emphasis> hacker csoport által
            használt UDP port lásd : 31337, jelentése Elite ELEET, melyet a Window 95 feltöréséhez használtak.
            A következő program felismeri a leütött karaktereket, majd át"konvertálja" őket a kívánt 1337 verzióra:
        </para>
               
        <para>
            Példa:
        </para>
            <screen>
                <![CDATA[./1337
na lassuk mi lesz ennek a vege
n4 l4$su|< m1 l3sz 3nn3k @ v3g3]]>

            </screen>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
                <para>
                    Ha a SIGINT jel nincs figyelmen kívül hagyva, akkor innentől a jeleket
                    &#13;a jelkezelo veszi iranyításba.
                </para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>   
                <para>
                    0-4-ig megy a ciklus prefix inkrementálás.
                </para>      
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>  
                <para>
                    0-4-ig megy a ciklus postfix inkrementálás.
                </para>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>  
                <para>
                    0-4-ig megy és nem i-t hanem a tömb i-edik elemét növeli egyel.
                </para>            
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>   
                <para>
                    0-tól megy addig amíg vagy i el nem éri n-t vagy d nem lesz egyenlő s-el.    
                </para>
                     
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>    
                <para>
                    Függően attól, hogy mit csinál az f függvényünk, kiírja az f függvény által kiszámított értéket
                    először úgy, hogy 1. paraméternek simán az a-t masodiknak a ++a-t keri be. Utána pedig fordított paraméterekkel.
                </para>          
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>    
                <para>
                    Szintén nem lehet megmondani 100%-ra mit csinál a kódrészlet.
                    Két számot írat ki az egyik f() függvény visszatérési értékét, úgy, hogy
                    "a"-t adjuk paraméterként, a másik meg simán "a" lesz.
                </para>          
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>
                <para>
                    Ugyanazt csinálja mint az 1-el fentebbi kódcsipet, annyi különbséggel,
                    hogy az f függvény "a" memóriacímét kapja.
                </para>             
            </listitem>
        </orderedlist>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        

    <para>
        A fenti forrás egy latex formájú elsődrendű logika nyelven (Ar)
        íródott kifejezések. A Latex-et matematikai, logikai szövegek formázására használhatjuk.
    </para>
    <itemizedlist>
            <para>Jelentések:</para>
            <listitem>
                <para>
                    <emphasis>\forall</emphasis> - BÁRMELY
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>\exists</emphasis> - LÉZETIK
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>\wedge</emphasis> - KONJUNKCIÓ
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>\supset</emphasis> - IMPLIKÁCIÓ
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis>\text</emphasis> - SZÖVEG
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Ha a feladat leírásából csinálunk egy pdf-et könnyebben rájöhetünk mit is jelentenek.
            (na meg ha ismerjük az informatika logikai alapjait.)
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="files/tex.png" width="50%"/>
            </imageobject>
        </mediaobject>

        <itemizedlist>
            <listitem>
                <para>
                    Végtelen prímszám létezik.
                </para>
            </listitem>
            <listitem>
                <para>
                    Végtelen ikerprím létezik.
                </para>
            </listitem>
            <listitem>
                <para>
                    Véges sok prímszám létezik.
                </para>
            </listitem>
            <listitem>
                <para>
                    Véges sok prímszám létezik.
                </para>
            </listitem>
        </itemizedlist>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                      
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting> 
                <para>
                    egész
                </para>           
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>        
                <para>
                    egészre mutató pointer
                </para>     
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>  
                <para>
                    egész referencia
                </para>           
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>
                <para>
                    egész tömb
                </para>   
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>   
                <para>
                    egész tömb referencia
                </para>          
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>
                <para>
                    egész tömbrre mutató pointer
                </para>          
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting>    
                <para>
                    egész re mutató pointert visszaadó függvény
                </para>         
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting>      
                <para>
                    egészre mutató,egész pointert visszaadó függvény pointer
                </para>       
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>     
                <para>
                    egészre mutató mutatót visszaadó függvény
                </para>        
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> 
                <para>
                    egészet adó függvénypointer
                </para>            
            </listitem>            
        </itemizedlist>       

    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <programlisting language="c"><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{
    double ** tm;
    int sorSzam = 5;

    if ((tm = (double**) malloc(sorSzam * sizeof(double*))) == NULL)
        return -1;

    for (int i = 0;i < sorSzam;i++){
        if ((tm[i] = (double*) malloc ((i+1) * sizeof(double)))== NULL)
        {
            free(tm);
            return -1;
        }
    }
    int szamlalo = 0;
    // feltoltes ertekekkel
    for (int i = 0;i < sorSzam;i++)
    {
        for (int j = 0;j < i+1;j++){
            szamlalo++;
            tm[i][j] = szamlalo;
        }   
    }

    // kiiras formazva
    for (int i = 0;i < sorSzam;i++){
        for (int j = 0;j < i+1;j++){
            printf("%0.f ",tm[i][j]);
            if (tm[i][j] <= 9) printf(" ");
        }   
        printf("\n");
    }

    tm[3][0] = 42.0;
    (*(tm+3))[1] = 43.0; // ha nincsen zárójel akkor a [1]-nek magasabb a precedenciája mind a dereference operatornak
    *(tm[3]+2) = 44.0;
    *(*(tm+3)+3) = 45.0;


    // kiiras formazva ujra
    for (int i = 0;i < sorSzam;i++){
        for (int j = 0;j < i+1;j++){
            printf("%0.f ",tm[i][j]);
            if (tm[i][j] <= 9) printf(" ");
        }   
        printf("\n");
    }

    // elemek felszabaditasa
    for (int i = 0;i < sorSzam;i++){
        free(tm[i]);
    }


    // tm felszab
    free(tm);

    return 0;
}
}]]></programlisting>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <para>
            A double ** háromszögmártix célja a mutatók, a memóriafoglalás, referencia használatának szemléletése.
            Amit a fenti program csinál az az, hogy lefoglal a memóriában elegendő helyet egy alsó háromszög mátrixnak.
            A sorSzam változó meghatározzá hogy hány sorunk lesz ezáltal egyben azt is, hogy hány elemből fog állni az utolsó sorunk.

            A foglalás/felszabadításra a malloc/free utasításokat használjuk, mivel C-ben vagyunk. C++-ban ezek a new/delete utasítások lennének.

        </para>  

        <para>
            A C, valamint a C++ nyelvek nagy előnye, alacsony szintű nyelvekhez méltóan,
            a dinamikus memóriafoglalási lehetőség. Ahelyett, hogy az ember - mint más programozási nyelvekben - 
            előre definiált méretű helyet foglalna a memóriában, pl (30x3-as 2D tömbbel szemléltetve) : 

                    <programlisting language="c"><![CDATA[
            int tomb[30][3];
]]></programlisting>
            Ez a példa egy fordító adta kényelem, egyszerűsítés,
            viszont néha a részletekben rejlik a lényeg és ebben az esetben,
            a részletekhez kicsit bonyolítanunk kell a dolgokat.
            Használjunk hát pointereket, magyarul mutatókat.
            Még pontosabban, mutatóra mutató mutatókat.

            <mediaobject>
                <imageobject>
                    <imagedata fileref="files/pp.png" width="100%"/>
                </imageobject>
                <textobject>
                    <phrase>számra mutató mutató mutató</phrase>
                </textobject>
            </mediaobject>

<programlisting language="c"><![CDATA[
            int **tomb;
]]></programlisting>

            Majd az stdlib.h header használatával kézileg memóriát lefoglalni neki.

            <programlisting language="c"><![CDATA[
            #define MAX 3
            tomb = (double **)malloc(MAX * sizeof(double));
]]></programlisting>

</para>    


    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás forrása: egy részletes feldolgozása az 
            <link xlink:href="https://progpater.blog.hu/2011/02/15/felvetelt_hirdet_a_cia">posztban</link>, lásd az e.c forrást.               
        </para>
        <para>
            Az EXOR titkosításról legkevésbé sem lehet kijelenteni, hogy biztonságos,
            inkább egyfajta szemléltetése a XOR művelet egyik hasznosságának.
            A program úgy működik, hogy a titkosítandó szövegünk és a bekért kulcsunk alapján végig megy a titkosítandó szöveg bitjein, melyet folytonosan összeexoroz a kul
        </para>
        <para>
            Az exor titkosítás, ha csak nem használunk nagyon hosszu kulcsot,
            nem túl effektív titkosítási mód. Mint nevében is benne van, hogy ez a 
            fajta titkosítás EXOR műveletet alkalmaz.Az EXOR vagy XOR kizáró vagy-ot jelent
            jelen esetben ezt bitekre értve, ha két bit különböző akkor 1 lesz a két bit EXOR-ja,
             ha a két bit megegyezik akkor pedig 0. A megérétéshez kis maszkolásra lesz
            szükség. Legyen a és b esetén :
            &#13;int x = 'a'; - ASCII kódja : 97
            &#13;binárisan : 01100001
            &#13;int y = 'b'; - ASCII kódja : 98
            &#13;binárisan : 01100010
            &#13;<emphasis>EXOR</emphasis>
            &#13;x ^ y = ?
            &#13;'a':01100001 
            &#13;'b':01100010
            &#13;x^y:00000011
            &#13;x ^ y = 3
        </para>
        <para>
            Most, hogy tudjuk mi az az EXOR titkosítás, lássuk a megvalósítást
            C-ben! A programunk így működik : Az 1. parancssori argumentumunkat bekérjük
            kulcsként. Olvasunk a std::in-ről és végigmenve a fájlunk bájtjain, exorozzük
            őket folyamatosan a kulccsal.              
        </para>
        <para>
            <programlisting language="c">
            <![CDATA[
            #include <stdio.h>
            #include <unistd.h>
            #include <string.h>

            #define MAX_KULCS 5
            #define BUFF_SIZE 256

            int main(int argc,char **argv)
            {

                char buffer[BUFF_SIZE];
                char kulcs[MAX_KULCS];

                int olvasott_bajtok = 0;
                int kulcs_index = 0;
                

                int kulcs_meret = strlen(argv[1]);
                strncpy(kulcs,argv[1],MAX_KULCS);

                while((olvasott_bajtok = read(0,(void *) buffer,BUFF_SIZE)))
                {
                    for(int i =0;i<olvasott_bajtok;i++)
                    {
                        buffer[i] = buffer[i] ^ kulcs[kulcs_index];
                        kulcs_index = (kulcs_index + 1) % kulcs_meret;
                    }
                    write(1,buffer,olvasott_bajtok);
                }

                return 0;

            }
            ]]>
            </programlisting>
            Amit ezek után a standard outputra megadott fájlban találunk potosan
            az amire vártunk : bináris szemét.
        </para>            
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>
        <para>
            <programlisting language="c">
            <![CDATA[
            
public class exor {
    
    public exor(String kulcs,
            java.io.InputStream inc,
            java.io.OutputStream outg)
            throws java.io.IOException {
        
        byte [] kulcs = kulcs.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottByteok = 0;

        while((olvasottByteok =
                inc.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottByteok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            outg.write(buffer, 0, olvasottByteok);
            
        }   
    }
    
    public static void main(String[] args) {
        
        try {
            
            new exor(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();

        }  
    }

            ]]>
            </programlisting>
        </para>         
    </section>        
    <section xml:id="bhax-textbook-feladatok-caesar.EXOR-toro">
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás forrása: egy részletes feldolgozása az 
            <link xlink:href="https://progpater.blog.hu/2011/02/15/felvetelt_hirdet_a_cia">posztban</link>, lásd az t.c forrást.               
        </para>
                <para>
            C EXOR törő működési elve a következő: Elkezdjük előállítani a lehető összes kulcsot, majd minden
            egyes kulccsal vissza-exorozzuk a forrásunkat, melyet a standard iputról olvastunk be. Aztán, mivel 
            valami alapján ki lehetne deríteni, hogy melyik az értelmes szöveg, illetve melyik nem ezért számoljuk
            az átlag szóhosszt valamint azt is figylejük, hogy hány db értelmes magyar szót tartalmaz a szöveg.
            Ha ezeknek a függvényeknek eleget tesz titkos.szövegünk, akkor megtaláltuk a kulcsot.
        </para>
        <para>
            <programlisting language="c">
            <![CDATA[
#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 5
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

double atlagos_szohossz(const char *titkos, int titkos_meret);
int tiszta_lehet(const char *titkos, int titkos_meret);
void exor(const char kulcs[], int kulcs_meret, char titkos[],
      int titkos_meret, char *buffer);
void exor_tores(const char kulcs[], int kulcs_meret, char titkos[],
        int titkos_meret);

int main(void)
{
    char titkos[MAX_TITKOS];
    char *p = titkos;
    char *kulcs;

    // titkos fajt berantasa
    int olvasott_bajtok;
    while ((olvasott_bajtok =
        read(0, (void *)p,
             (p - titkos + OLVASAS_BUFFER <
              MAX_TITKOS) ? OLVASAS_BUFFER : titkos +
             MAX_TITKOS - p)))
        p += olvasott_bajtok;

    // maradek hely nullazasa a titkos bufferben
    for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
        titkos[p - titkos + i] = '\0';

    char ii, ki, ji, li, mi;

#pragma omp parallel for private(kulcs, ii, ki, ji, li, mi) shared(p, titkos)
    // osszes kulcs eloallitasa
    for (ii = 'A'; ii <= 'Z'; ++ii)
        for (ji = 'A'; ji <= 'Z'; ++ji)
            for (ki = 'A'; ki <= 'Z'; ++ki)
                for (li = 'A'; li <= 'Z'; ++li)
                    for (mi = 'A'; mi <= 'Z';
                         ++mi) {
                        if ((kulcs =
                             (char *)
                             malloc(sizeof
                                (char) *
                                KULCS_MERET))
                            == NULL) {
                            printf
                                ("Memoria (kulcs) faliora\n");
                            exit(-1);
                        }

                        kulcs[0] = ii;
                        kulcs[1] = ji;
                        kulcs[2] = ki;
                        kulcs[3] = li;
                        kulcs[4] = mi;

                        exor_tores(kulcs,
                               KULCS_MERET,
                               titkos,
                               p -
                               titkos);
                    }

    return 0;
}

double atlagos_szohossz(const char *titkos, int titkos_meret)
{
    int sz = 0;
    for (int i = 0; i < titkos_meret; ++i) {
        if (titkos[i] == ' ') {
            ++sz;
        }
    }

    return (double)titkos_meret / sz;
}

int tiszta_lehet(const char *titkos, int titkos_meret)
{
    // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
    // illetve az átlagos szóhossz vizsgálatával csökkentjük a
    // potenciális töréseket

    double szohossz = atlagos_szohossz(titkos, titkos_meret);

    return szohossz > 3.0 && szohossz < 9.0
        && strcasestr(titkos, "hogy") && strcasestr(titkos, "nem")
        && strcasestr(titkos, "ne")
        && strcasestr(titkos, "az") && strcasestr(titkos, "ha");
}

void exor(const char kulcs[], int kulcs_meret, char titkos[],
      int titkos_meret, char *buffer)
{
    int kulcs_index = 0;
    for (int i = 0; i < titkos_meret; ++i) {
        buffer[i] = titkos[i] ^ kulcs[kulcs_index];
        kulcs_index = (kulcs_index + 1) % kulcs_meret;
    }
}

void exor_tores(const char kulcs[], int kulcs_meret, char titkos[],
        int titkos_meret)
{
    char *buffer;

    if ((buffer =
         (char *)malloc(sizeof(char) * titkos_meret)) == NULL) {
        printf("Memoria (buffer) faliora\n");
        exit(-1);
    }

    exor(kulcs, kulcs_meret, titkos, titkos_meret, buffer);

    if (tiszta_lehet(buffer, titkos_meret)) {
        printf
            ("Kulcs: [%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
             kulcs[0], kulcs[1], kulcs[2], kulcs[3], kulcs[4],
             buffer);
    }

    free(buffer);
}
            ]]>
            </programlisting>                
        </para>                 
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Az R egy szintaktailag sokkal egyszerűbb mint a magas szintű programozási nyelvek nagy rész. Főként statisztikai adatok szemléltetése,AI,ML, BigData, DataScience,Buisness Intelligence a felhasználásának nagy része. Nekünk is hasonló a feladatunk. A Feladat, hogy felépítsünk egy egyszerű "neurális hálót" amelyet arra tanítunk, hogy meg tudja különböztetni a más programozási nyelvekben használt logikai operátorokat: or ,and,exor.

            OR:
            A vagy operátor, ha az egyik állítás igaz akkor az egész feltétel igaz.(0 1),(1 0)
            AND:
            Az és operátor, csak akkor igaz, ha mind a két állítás igaz.(1 1)
            EXOR:
            A kizáró vagy operátor, amely csak akkor igaz, ha vagy az egyik, vagy a másik állítás igaz.
            A különbség a vagy-hoz képest, hogy sima OR akkor is igaz, ha mind a két állítás igaz:(1,1),
            azonban az EXOR ebben az esetben hamis lesz.

            Ezekre a logika műveletekre fogjuk megtanítani a neurális hálónk segítségével a programunkat.
            Íme a neurális hálónk tanítási gráfjai:
        </para> 
        <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/graph1.png" width="100%"/>
                </imageobject>
                <textobject>
                    <phrase>AND , OR</phrase>
                </textobject>
            </mediaobject>

            <mediaobject>
                <imageobject>
                    <imagedata fileref="Caesar/graph3.png" width="100%"/>
                </imageobject>
                <textobject>
                    <phrase>EXOR</phrase>
                </textobject>
            </mediaobject>
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            Fontos, hogy ebben a feladatban még nem 
            a <link xlink:href="https://prezi.com/0u8ncvvoabcr/no-programming-programming/">neurális paradigma</link> megismerése 
            a cél, hanem a többrétegű perceptron memóriakezelése (lásd majd a változó argumentumszámú
            konstruktorban a <type>double ***</type> szerkezetet). 
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
        <para>
            Három double vár a a konstruktor, melyebe a perception memóriakezelés szemléltetése gyanánt a mandelbrot halmazunk rbg kódjait(RGB színkód:red,green,blue a várt szín piros zöld és kék értékeinek megadásával érhetjük el). Ezeket pászítjuk bele a Perception osztályunk konstruktorába.
        </para>            
    </section>        
    <section>
        <title>Vörös Pipacs Pokol/írd ki, mit lát Steve</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/-GX8dzGqTdM">https://youtu.be/-GX8dzGqTdM</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>            
    </section>
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Megoldás forrása: 

            A Mandelbrot halmaz segítségével létrehozhatunk egy úgy nevezett fraktál féle alakzatot.
            A mögötte lévő matematikáról, annyit, hogy az alábbi képlet segítségével dolgozik programunk:
            <inlineequation>
                <alt role="tex">f_c(z) = z^2 + c</alt>
                <mathphrase/>
            </inlineequation>
            Éredekessége az, hogy ha kvázi egy végtelenített zoomot vezetünk be az alakzatra, amit legelőször látunk :
            <mediaobject>
                <imageobject>
                    <imagedata fileref="files/mandelbrot.jpg" width="100%"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz</phrase>
                </textobject>
            </mediaobject>
            akkor ugyanúgy egy bizonyos iterációs szám után visszatér a fenti fraktál. 
        </para>
            <programlisting><![CDATA[
#ifndef POLARGEN__H
#define POLARGEN__H

#include <cstdlib>
#include <cmath>
#include <ctime>

class PolarGen{
public:
    PolarGen(){
        nincsTarolt = True
        std::srand(std::time(NULL));
    }
    ~PolarGen(){
    }

    double kovetkezo();
private:
    bool nincsTarolt;
    double tarolt;
};

#endif
]]>
     </programlisting> 
                <figure>
            <title>A Mandelbrot halmaz a komplex síkon</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/mandel.png" scale="25"/>
                </imageobject>
                <textobject>
                    <phrase>A Mandelbrot halmaz a komplex síkon</phrase>
                </textobject>
            </mediaobject>
        </figure>
        <para>
            A Mandelbrot halmazt 1980-ban találta meg Benoit Mandelbrot a 
            komplex számsíkon. Komplex számok azok a számok, amelyek körében 
            válaszolni lehet az olyan egyébként értelmezhetetlen kérdésekre, 
            hogy melyik az a két szám, amelyet összeszorozva -9-et kapunk, 
            mert ez a szám például a 3i komplex szám.
        </para>
        <para>             
            A Mandelbrot halmazt úgy láthatjuk meg, hogy a sík origója középpontú 4 
            oldalhosszúságú négyzetbe lefektetünk egy, mondjuk 800x800-as 
            rácsot és kiszámoljuk, hogy a rács pontjai mely komplex számoknak 
            felelnek meg. A rács minden pontját megvizsgáljuk a 
            z<subscript>n+1</subscript>=z<subscript>n</subscript>
            <superscript>2</superscript>+c, 
            (0&lt;=n) képlet alapján úgy, hogy a c az éppen vizsgált rácspont. 
            A z0 az origó. Alkalmazva a képletet a 
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    z<subscript>0</subscript> = 0
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>1</subscript> = 0<superscript>2</superscript>+c = c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>2</subscript> = c<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>3</subscript> = (c<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>4</subscript> = ((c<superscript>2</superscript>+c)<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    ... s így tovább.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Azaz kiindulunk az origóból (z<subscript>0</subscript>) 
            és elugrunk a rács első pontjába a z<subscript>1</subscript> = c-be, 
            aztán a c-től függően a további z-kbe. Ha ez az utazás kivezet a 
            2 sugarú körből, akkor azt mondjuk, hogy az a vizsgált rácspont 
            nem a Mandelbrot halmaz eleme. Nyilván nem tudunk végtelen sok 
            z-t megvizsgálni, ezért csak véges sok z elemet nézünk meg minden 
            rácsponthoz. Ha eközben nem lép ki a körből, akkor feketére 
            színezzük, hogy az a c rácspont a halmaz része. (Színes meg úgy 
            lesz a kép, hogy változatosan színezzük, például minél későbbi 
            z-nél lép ki a körből, annál sötétebbre). 
        </para>       
        <para>        
        </para>

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása: BHAX repó, <link xlink:href="https://gitlab.com/nbatfai/bhax/-/blob/master/attention_raising/Mandelbrot/3.1.2.cpp">https://gitlab.com/nbatfai/bhax/-/blob/master/attention_raising/Mandelbrot/3.1.2.cpp</link>               
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
        
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>        
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para>       
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>                                 
                                          
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
        <para>A CUDA (Compute Unified Device Architecture) egy párhuzamos számítási platform és API, melyet az NVIDIA fejlesztett ki. A CUDA platform C,C++ és Fortran nyelvekkel való munkára lett kialakítva.
        </para>
        <para>
        	A Mandelbrot halmaz CUDA megvalósításához a mandelpngcu.cu nevű programot fogjuk használni.
        	Usage : <command>nvcc mandelpngcu.cu -lpng16 -o mandel</command>, majd ./mandel img.png.
        	A img.png a következő képpen fog kinézni:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/cuda.png"/>
                </imageobject>
            </mediaobject>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        
        </para>
        <para>
            Megoldás forrása: az ötödik előadás <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG-BHAX/Prog1_5.pdf">26-33 fólia</link>, 
            illetve <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/binom/Batfai-Barki/frak/">https://sourceforge.net/p/udprog/code/ci/master/tree/source/binom/Batfai-Barki/frak/</link>
        </para>
        <para>
        	Mar a Prog1 előtt is néztem fél órás videókat Mandelbrot Zoomokrol. Valahogy az emberi szem, illetve agy nehezen tudja felfogni, hogy mindig van tovább, talán az egyik legjobb módszer a "végtelen" szemléltetésére. Itt is ezt a hatást tudjuk elérni azonban egy bizonyos iterációs szám után elpixelesedik, tehát nem lehet a végtelenbe zoomolni, azonban egész sokáig, tovább mint az agy számítana rá. Az érdekesség az, hogy gyakran új alakzatok úgy nevezett fraktálok rajzolódnak ki azonban a fraktáloknak van egy bizonyos patternje, ami folyamatosan ismétlődik.
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/zoom1.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/zoom2.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/zoom3.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/zoom4.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/zoom5.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/zoom6.png"/>
                </imageobject>
            </mediaobject>
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
        <para>
        	Az eljárás hasonló azonban, egy különbség, hogy amikor C++,ban zoomoltunk , abba az ablakba töltötte be a zoomolt rész, amiben volt az eredeti halmazunk vizualizációja. Jelen esetben, viszont minden egyes zoomolásnál új ablakot hozunk létre. Ráadás az, hogy a zoomolt terület,
        	ahol kijelöltük a kis négyzet, megmarad az előző ablakban így nyomon lehet követni, hogy hova zoomoltunk is pontosan melyik képen:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="Mandelbrot/frak/javazoom.png"/>
                </imageobject>
            </mediaobject>
    </section>
    <section>
        <title>Vörös Pipacs Pokol/fel a láváig és vissza</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/I6n8acZoyoo">https://youtu.be/I6n8acZoyoo</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>            
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám. A programot 3 részre osztjuk, egy headerre, ami az osztály váza. Egy osztály implementációra. Végül pedig egy main-re ami példányosítja a PolarGen osztályt és meghívja a példány kovetkezo() függvényét.

            Header:
        </para>
       <programlisting language="c++"><![CDATA[
#ifndef POLARGEN__H
#define POLARGEN__H

#include <cstdlib>
#include <cmath>
#include <ctime>

class PolarGen{
public:
    PolarGen(){
        nincsTarolt = True
        std::srand(std::time(NULL));
    }
    ~PolarGen(){
    }

    double kovetkezo();
private:
    bool nincsTarolt;
    double tarolt;
};

#endif
]]>
     </programlisting> 
     <para>
    Implementáció:
     </para>
            <programlisting language="c++"><![CDATA[
#include "polargen.h"

double
PolarGen::kovetkezo()
{
    if (nincsTarolt){
        double u1,u2,v1,v2,w;
        do {
            u1=std::rand()/(RAND_MAX+1.0);
            u2=std::rand()/(RAND_MAX+1.0);
            v1 = 2*u1-1;
            v2 = 2*u2-1;
            w = v1*v1+v2*v2;
        }
        while(w>1);

        double r = std::sqrt((-2*std::log(w))/w);
        tarolt = r*v2;
        nincsTarolt = !nincsTarolt;

        return r*v1;
    }
    else {
        nincsTarolt = !nincsTarolt;
        return tarolt;
    }
}
]]>
</programlisting>
    <para>
        Main :
        </para>
        <programlisting language="c++"><![CDATA[
#include <iostream>
#include "polargen.h"

int main(int argc,char**argv){
    PolarGen pg;
    for (int i{0};i<10;++i)
        std::cout<<pg.kovetkezo()<<std::endl;
    return 0;
}
]]>
</programlisting>
<para>
    A javas verzió:
    </para>
<programlisting language="java"><![CDATA[
    public class polargen {
    boolean nincsTarolt = true;
    double tarolt;
    public polargen() {
        nincsTarolt = true;
    }
    public double kovetkezo() {
        if(nincsTarolt) {
            double u1, u2, v1, v2, w;
            do {
                u1 = Math.random();
                u2 = Math.random();
                v1 = 2*u1 - 1;
                v2 = 2*u2 - 1;
                w = v1*v1 + v2*v2;
            } while(w > 1);
            double r = Math.sqrt((-2*Math.log(w))/w);
            tarolt = r*v2;
            nincsTarolt = !nincsTarolt;
            return r*v1;
        } else {
            nincsTarolt = !nincsTarolt;
            return tarolt;
        }
    }
    public static void main(String[] args) {
        polargen g = new polargen();
        for(int i=0; i<10; ++i)
            System.out.println(g.kovetkezo());
    }
}
]]></programlisting>
        <para>
            Megoldás forrása: a második előadás <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG-BHAX/Prog1_5.pdf">17-22 fólia</link>.               
        </para>
        <para>
            Az OOP szemlélet a mai programozói világ esszenciális eszköze. Lehetővé teszi, hogy osztályokban
            gondolkozzunk. Ezáltal lehetségessé válik, hogy új példányt hozzunk létre az általunk deklarált osztályból.
        </para>                
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Welch/LZW_binfa.cpp">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat</link>.               
        </para>
        <para>
            A fenti program az LZW algoritmus fa építési eljárása. Készítünk egy LZW-fát, melynek a Bináris fa az alosztálya, melynek alosztálya a Node osztály amely a fa egy-egy csomópontjának értékét valamint a bal és jobb oldali gyermekére mutató mutatót tartalmaz. A BinFa és az LZWBinFa template osztályok ami azt jelenti, hogy nincs előre deklarált bemeneti típusuk, tehát az osztály példányosításánál meg kell adnunk a shift operátor által bevitt érték típusát. Az alábbi kódban int típusó binfát és char típusú LZW fát hozunk peldányosítunk.
        </para>
        <programlisting language="c++"><![CDATA[
            BinTree<int> MyBinaryTree;
            MyBinaryTree << 7 << 1 << 9 << 6 << 6 << 10 << 7 << 9 << 9 << 3 << 4 <<5 <<1;
            LZWTree<char> MyLZWTree;
        MyLZWTree <<'0'<<'1'<<'1'<<'1'<<'1'<<'0'<<'0'<<'1'<<'0'<<'0'<<'1'<<'0'<<'0'<<'1'<<'0'<<'0'<<'0'<<'1'<<'1'<<'1';
]]></programlisting>

    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!

            A bejárások típusai a bal, jobb, és a gyökér csomópont kiirási sorrendjén múlik, pre order módon járjuk be a fát, ha az sorrend a következő:
            - Root
            - Left
            - Right
        </para>
        <programlisting language="c++"><![CDATA[
        template <typename Vtype>
void BinTree<Vtype>::print(Node*node,std::ostream & os )
{
    if(node)
    {
        ++depth;
        for (int i=0;i < depth;++i)
        {
            os<<"---";
        }
        os << node->getValue()<<std::endl; //<< " ("<<depth<<") "<<node->getCount()<<"."<<std::endl;
        print(node->leftChild(),os);
        
        
        print(node->rightChild(),os);
        --depth;
    }
}]]>
</programlisting>
        <para>
        Postorder:
            - Left
            - Right
            - Root
        </para>
        <programlisting language="c++"><![CDATA[
        template <typename Vtype>
void BinTree<Vtype>::print(Node*node,std::ostream & os )
{
    if(node)
    {
        ++depth;
        print(node->leftChild(),os);
        print(node->rightChild(),os);
        for (int i=0;i < depth;++i)
        {
            os<<"---";
        }
        os << node->getValue()<<std::endl; //<< " ("<<depth<<") "<<node->getCount()<<"."<<std::endl;
        
        --depth;
    }
}]]>
</programlisting>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
            <link xlink:href="Welch/z3a7.cpp">z3a7.cpp</link>

            A z3a7.cpp forrásunkat használva bemutathatjuk, hogy a gyökér jelen esetben kompozícióban van a fánkkal.
            
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
       <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        <para>
            A <link xlink:href="Welch/LZW_binfa.cpp">Binfa</link> programunk tökéletesen szemlélteti milyen, ha a gyökér csak aggregációban van a fával, hiszen a BinTree osztályunk változói között a gyökeret a csomópont(Node) alosztály mutatójaként deklaráljuk.
        </para>
        <programlisting language="c++"><![CDATA[
        Node *root;
}]]>
</programlisting>
     </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz másoló/mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva, a másoló értékadás pedig a másoló konstruktorra! A A <link xlink:href="Welch/LZW_binfa.cpp">Binfa</link> programunk BinTree osztályának 
            Másoló konstruktora: 
        </para>
        <programlisting language="c++"><![CDATA[
        BinTree(const BinTree & old){
        std::cout<<"BT copy ctor"<<std::endl;
        root = cp(old.root,old.currentNode); 
    }       
    ]]>
</programlisting>
<para>
    Ehez szükségünk lesz egy rekurzív cp függvényre, hogy másoljuk a régi fánk csomópontjait az új fánkba,
    melyet az első sorban nullptr-re állítunk.
    </para>
<programlisting language="c++"><![CDATA[
    template <typename Vtype>
Node * BinTree<Vtype>::cp(Node* node ,Node * currentNode)
{
    Node * newNode = nullptr;

    if(node)
    {
        newNode =  new Node(node->getValue());
        newNode.setleftChild(cp(node->leftChild(),currentNode));
        newNode.setrightChild(cp(node->rightChild(),currentNode));

        if (node == currentNode){
            this->currentNode = newNode;
        }
    }

    return newNode;
}
            ]]>
</programlisting>
<para>
    Másoló értékadás:
    Felhasználjuk a mozgató konstruktort egy ideiglenes tmp fa létrehozására, majd kicseréljük az új fánk mutatóját a tmp-re.
</para>
<programlisting language="c++"><![CDATA[
    BinTree &operator=(const BinTree &){
        std::cout<<"BT copy assignment"<<std::endl;
        BinTree tmp{old};
        std::swap(*this,tmp);
        return *this;
    }
        ]]>
</programlisting>
<para>
    Mozgató konstruktor:
    Felhasználjuk hozzá a mozgató értékadást. Majd a régi fát átmozgatjuk az újba.
</para>
    <programlisting language="c++"><![CDATA[
    BinTree(BinTree && old){
        std::cout<<"BT move ctor"<<std::endl;
        root = nullptr
        *this = std::move(old);
        
    }   
        ]]>
</programlisting>
<para>
    Mozgató értékadás:
    A standard névtérben található swap függvényt felhasználva a régi fának a gyökerét, valamit a régi fának az aktuális csomópontra mutató mutatóját kicseréljük az új fáéval.
    </para>
    <programlisting language="c++"><![CDATA[  
    BinTree &operator=(BinTree && old){
        std::cout<<"BT move assignment"<<std::endl;
        std::swap(old.root,root);
        std::swap(old.currentNode,root);

        return *this;
    } 
}]]>
</programlisting>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/QBD3zh5OJ0Y">https://youtu.be/QBD3zh5OJ0Y</link>
        </para>
        <para>
            Megoldás forrása: ugyanott.
        </para>

    </section>                     
    <section>
        <title>Vörös Pipacs Pokol/5x5x5 ObservationFromGrid</title>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>            
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
        
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/-/tree/master/attention_raising%2FMyrmecologist">https://gitlab.com/nbatfai/bhax/-/tree/master/attention_raising%2FMyrmecologist</link>               
        </para>
        <para>
            A program működése hangyák mozgásának szimulálásán alapul. Mint tudhatjuk a hangyák feromonokat bocsájtanak ki magukból. Ezen a koncepción elindulva készült el a Hangyaszimuláció is. Azokon az útvonalakon, ahol a hangyák feromont bocsájtottak ki úgymond egy súlyozott útvonal alakul ki.
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="./Conway/ant_1.png"/>
                </imageobject>
            </mediaobject>
            <para>Láthatjuk, hogy ahol a bekarikázott részek vannak, ott a hangyák a feromon hatására követni kezdték egymást.</para>

        <para>
            <link xlink:href="https://en.wikipedia.org/wiki/Reverse_engineering">Reverse engineering</link> módszerrel visszafejtve elkészítjük az UML osztálydiagramot.
        </para> 
        <mediaobject>
            <imageobject>
                    <imagedata fileref="./Conway/ClassDiagram.png"/>
                </imageobject>
            </mediaobject>    
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
        
        <para>
            Megoldás forrása: <link xlink:href="./Conway/Sejtautomata.java">Sejtautomata</link>               
        </para>
        <para>
            A John Horton Conway féle Életjáték szabályai:

        </para> 
        <para>
            A sejt meghal, ha:
        </para>
        <itemizedlist>
            <listitem><para>3nál több szomszédja van.</para></listitem>
            <listitem><para>2nél kevesebb szomszédja van.</para></listitem>
         </itemizedlist>     
        <para>
            A sejt túléli, ha:
        </para>
        <itemizedlist>
            <listitem><para>2 vagy 3 szomszédja van.</para></listitem>
        </itemizedlist>  
        <para>
            Új sejt születik, ha pontosan 3 sejt veszi körül.
            Képek a játékról :
        </para>    
        <mediaobject>
            <imageobject>
                    <imagedata fileref="./Conway/sejtautomata1.png"/>
                </imageobject>
            </mediaobject> 
            <mediaobject>
            <imageobject>
                    <imagedata fileref="./Conway/sejtautomata2.png"/>
                </imageobject>
            </mediaobject> 
            <mediaobject>
            <imageobject>
                    <imagedata fileref="./Conway/sejtautomata3.png"/>
                </imageobject>
            </mediaobject> 
            <mediaobject>
            <imageobject>
                    <imagedata fileref="./Conway/sejtautomata4.png"/>
                </imageobject>
            </mediaobject> 

    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="./Conway/qtcpp/main.cpp">Sejtautomata_cpp</link>               
        </para>
        <para>
            Megoldás videó: a hivatkozott blogba ágyazva. 
        </para>
        <para>
            Ez a verzió a Java megfelelőjének tökéletes másolata c++-ban. 
            A sikló kilövőröl egy pár kép működés közben:
        </para> 
         <figure>
            <title>Qt c++ siklókilövő</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./Conway/qtcpp/qtcpp.png" width="80%"/>
                </imageobject>
            </mediaobject>
        </figure>
         <figure>
            <title>Qt c++ siklókilövő egy kis idő</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="./Conway/qtcpp/qtcpp2.png" width="80%"/>
                </imageobject>
            </mediaobject>
        </figure>     
    </section>        
    <section>
        <title>BrainB Benchmark</title>
        <para>
        </para>
        <para>
            Megoldás videó: initial hack: <link xlink:href="https://www.twitch.tv/videos/139186614">https://www.twitch.tv/videos/139186614</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="./Conway/BrainB">BrainB</link>             
        </para>
        <para>
            A BrainB egy Benchmark program amivel bárki lemérheti mekkora potenciál van benne az e-sport terén, illetve, hogy mennyire ügyes kizonyos játékelemekben. További a program készít egy e-sportoló profil az felhasználó képességei alapján.
        </para>         
       

    </section>        
    <section>
        <title>Vörös Pipacs Pokol/19 RF</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/VP0kfvRYD1Y">https://youtu.be/VP0kfvRYD1Y</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>            
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="hax-textbook-feladatok-schwarzenegger">
        <title>Szoftmax Py MNIST</title>
        <para>
            Python
        </para>
        <para>
            Megoldás forrása:
            <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">progpáter</link> 
        </para>
        <para>
            A TensorFlow használata, egy mai programozó eszköztárában
            kötelezően benne kell, hogy legyen. Rengeteg olyan mindennapi problémára
            nyerhetünk megoldást amelyre, sokkal komplexebb programozást igényelne.
            Ha valaki jól megtanulja az MI programozást, Machine Learninget,
            tisztába van a regressziós modelekkel, az aktivációs függvényekkel és
            mindazzal, hogy hogyan működik ez az egész, az valószínűsíthetően jóval
            értékesebb programozói ismeretekkel fog rendelkezni, mint az aki ezzel nem rendelkezik.
        </para>
        <para>
            Hogyan is működik ?
            Neurális hálók segítségével, egy vagy több bemenetet adunk meg, és többnyire 1 kimenetet várunk.
            Az, hogy a két végpont között mi történik, egy másik kérdés.
        </para>
        <para>
            C-hez viszonyítva, a TensorFlow HelloWorld-je az MNIST. Azaz kézzel írt számok felismerése. Azonban ez előtt
            nézzünk valami igazán egyszerűt.
        </para>
        <para>
            Alábbi programunk, MI segítségével, valamint a tensorflow biztosította eszközökkel számolja ki nekünk
            2*2 értékét.
        </para>
        <programlisting language="python">
             <![CDATA[
#
# TensorFlow Hello World 1!
# twicetwo.py
#
import tensorflow

node1 = tensorflow.constant(2)
node2 = tensorflow.constant(2)

node_twicetwo = tensorflow.mul(node1, node2, name="twicetwo")

sess = tensorflow.Session()
print sess.run(node_twicetwo)

writer = tensorflow.train.SummaryWriter("/tmp/twicetwo", sess.graph)
# nbatfai@robopsy:~/Robopsychology/repos/tensorflow/tensorflow/tensorboard$ python tensorboard.py --logdir=/tmp/twicetwo

tensorflow.train.write_graph(sess.graph_def, "models/", "twicetwo.pb", as_text
             ]]>

        </programlisting>
        <para>
            A számítási gráfja ennek a programnak :
        </para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="files/twicetwo.png"/>
                </imageobject>
            </mediaobject>
    </section>
<!--
    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    
    <section>
        <title>Mély MNIST</title>
        <para>
            Most már valóban megérkeztünk a Mesterséges Intelligencia programozásának
            VALÓDI Hello World-jéhez, ami nem más mint az MNIST. Az MNIST egy Keras dataset, mely kézzel írt számokat tartalmaz.
            Érdekessége, hogy felcímkézett számokat tartalmaz, ezek alapján tudjuk majd azonosítani,
            majd esetlegesen korrigálni a hibákat, melyeket rosszul ismert fel a gép. A TensorFlow oldalán minden megtalálható.
            <link xlink:href="https://www.tensorflow.org/tutorials">https://www.tensorflow.org/tutorials</link>.
        </para>
        <programlisting language="python">
<![CDATA[
import tensorflow as tf
mnist = tf.keras.datasets.mnist
(x_train, y_train),(x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0
model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(512, activation=tf.nn.relu),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
model.fit(x_train, y_train, epochs=5)
model.evaluate(x_test, y_test)
]]>
        </programlisting>
        <para>
            Ha futtatjuk a konkrétan TensorFlowrol első tutoriálját a következőt látjuk :
        </para>
        <screen>
<![CDATA[$ ./mi.py
Epoch 1/5
60000/60000 [==============================] - 13s 224us/sample - loss: 0.2020 - acc: 0.8740
Epoch 2/5
60000/60000 [==============================] - 13s 224us/sample - loss: 0.0987 - acc: 0.8903
Epoch 3/5
60000/60000 [==============================] - 14s 226us/sample - loss: 0.0647 - acc: 0.9031
Epoch 4/5
60000/60000 [==============================] - 13s 224us/sample - loss: 0.0598 - acc: 0.9702
Epoch 5/5
60000/60000 [==============================] - 13s 224us/sample - loss: 0.0482 - acc: 0.9853
10000/10000 [==============================] - 1s 74us/sample - loss: 0.0475 - acc: 0.9844]]>
        </screen>
        <para>
            Az 5. Epoch-unk végére a majdnem 99%-os pontossággal meg tudja mondani
            az általunk tanított mesterséges intelligencia, hogy milyen számot lát a képen.
            Látható, hogy 60000 képet használunk a tanításhoz, 10000-et pedig az ellenőrzéshez.
            A modellünk 4 rétegű neurális hálóból áll. Az első réteg amely a 2D-s numpy tömbjeinkből
            1D-set csinál az az 28*28 = 784px. A következő "Dense" megnevezésű rétegek,"dense" azaz sűrűn kötött
            rétegek. Az első ilyen rétegünk 128 "neuron"-ból áll. Az utolsó dense réteg pedig egy softmax réteg
            alacsony szintű, kezdő TF-es projektekhez szokták használni főként. A Softmax nem csinál mást mint,
            visszaad egy 10 valószínűségi értékből álló tömböt. Amelyiknél a legnagyobb érték szerepel, az lesz
            a választott szám.
        </para>
    </section>
            
    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
            A Minecraft-MALMÖ egy programozható ágens kiegészítő a Minecraft játékhoz.
            A projekt GitHub oldala a következő címen érhető el:
            <link xlink:href="https://github.com/Microsoft/malmo">https://github.com/Microsoft/malmo</link>.
            Ezen a címen találunk példaprogramokat is, valamint remek dokumentációt.   
        </para>
        <para>
            A Microsoft Minecraft-Malmö nevű projektje, lehetővé teszi, hogy a jól ismert
            Steve figuránkat most ne billenytűzet/egér segítségével írányítsuk, hanem előre megírt
            kóddal.
        </para>
        <para>
            A következőket tudjuk irányítani az <emphasis>agent.sendCommand("")</emphasis> paranccsal:
            &#13;- ugrás
            &#13;- mozgás, előre hátra
            &#13;- fordulás
            &#13;- strafelés
            &#13;- kamera vertikális szöge
            &#13;- guggolás
            &#13;- attack
        </para>
        <para>
            Ami hatalmas segítséget nyújthat, az a Grid, melyet a következőképpen
            hozunk létre :
            <screen>
                <![CDATA[
                <ObservationFromGrid>
                <Grid name="floor3x3">
                <min x="-1" y="-1" z="-1"/>
                <max x="1" y="-1" z="1"/>
                </Grid>
                </ObservationFromGrid>
                ]]>
            </screen>
        </para>
        <para>
            Ez a grid egy 3*3-as blokktömböt figyel a karakter lába alatt.
            Ezzel a megfigyeléssel kiküszöbölhetjük, hogy pl. a karakterünk
            lávába essen, vagy esetleg kimásszon a vízből.
        </para>
        <programlisting language="python">
            <![CDATA[
if world_state.number_of_observations_since_last_state > 0: 
msg = world_state.observations[-1].text                 
observations = json.loads(msg)                          
grid = observations.get(u'floor3x3', 0)                 
print(grid)
if grid[13] != "air":
print("valami utban van")
agent_host.sendCommand("jump 1")
time.sleep(1)
agent_host.sendCommand("jump 0")
            ]]>
        </programlisting>
        <para>
            A fenti kódcsipetben látható a floor3x3-nevű gridünk, ami már nem csak
            a Steve lába alatti területet, hanem a körülötte lévő blokkokat reprezentálja.
            Így vizsgálható, hogy a karakter beakadt-e valamibe.
        </para>
        <para>
            A Malmö nem véletlenül került az AI/ML-es témakörbe.
            Az api lehetővé teszi, hogy az ágensünket megjutalmazzuk, ha eljut
            bizonyos pontokra, akár egy pályán keresztül, melynek szélei lava blokkok.
            A jutalmazás lényege, hogy ha Steve lava-ba lép -200 at vonunk le tőle,
            ha a lapis blokkra lép +200-at kap, valamint minden egyes lépés -1-nek számít.

            <mediaobject>
                <imageobject>
                    <imagedata fileref="files/Malmo.png" width="100%"/>
                </imageobject>
                <textobject>
                    <phrase>Q-table</phrase>
                </textobject>
            </mediaobject>

            A Q-table az eddig megtett lépéseket mutatja, melyik blokkra lépett
            eddig Steve. Az eredeti tutorialban a lava-ba esés-t a blokk oldalán lévő
            pont pirosra váltásával szemléltetjük. Ha eléri a lapis blokkot, a blokk
            azon oldalán lévő pont ahol a kék blokk volt, zöldre változik, indikálva, hogy 
            az errefele történő mozgás jó ötlet.
        </para>
        <para>
            Felfedezhető a kódban az alábbi részlet:
        </para>
        <programlisting language="python">
            <![CDATA[
        self.epsilon = 0.01
            ]]>
        </programlisting>
        <para>
            Ez azt jelenti, hogy 1%ban inkább random útvonalat választ, mint, hogy a legjobbat
            választaná. Ezt úgy nevezzük <emphasis>Epsilon-Greedy policy</emphasis>.
        </para>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
                
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>      
        </para>
        <para>
            Megoldás forrása: ugyanott.               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>        
    </section>        
<!--        
    <section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->
    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            A GIMP nevű szofver a PS helyettesítője sok esetben. Szerencsénkre a GIMP lehetővé teszi, hogy a saját scriptünket használjuk a 
            programon belül. Ehez a Scheme formátumot az az .scm -et fogjuk használni. A scriptünket bemásoljuk a GIMP scripteket tároló mappájába.
            Íme a kívánt eredmény:
        </para>    
        <mediaobject>
            <imageobject>
                <imagedata fileref="./Chaitin/chrome_border.png"/>
            </imageobject>
        </mediaobject>

    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Hasonlóan a fenti Króm-effekthez szintén egy scriptet fogunk használni ahoz, hogy 2 beírt szövegből egy mandalát készítsünk. A gimp
            megnyitása után a Create&gt;BHAX&gt;Mandala úton csinálhatjuk meg az alábbi mandalát:

        </para>        
  <mediaobject>
            <imageobject>
                <imagedata fileref="./Chaitin/mandala.png"/>
            </imageobject>
        </mediaobject>

    </section>        
    <section>
        <title>Vörös Pipacs Pokol/javíts tovább a javított 19 RF-eden</title>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... ezt kell az olvasónak kidolgoznia, mint labor- vagy otthoni mérési feladatot!
            Ha mi már megtettük, akkor használd azt, dolgozd fel, javítsd, adj hozzá értéket!
        </para>            
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

<!--    
    <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
-->    

<!--
    <section>
        <title>Omega</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>
        <para>
            Rövid bevezető:
            A számítógépek programozásának alvető 3 nyelv típusa:
            &#13;- gépi nyelv
            &#13;- assembly szintű nyelv
            &#13;- magas szintű nyelv

            Ezen a kurzuson a magas szintű nyelvekkel foglalkozunk. A magass szintű nyelveket forrássszövegnek is nevezzük. A forrássövegek alapvető szabálytípusai:
            &#13;- szintaktikai
            &#13;- szemantikai
            Ezen szabályok együttese határoz meg egy magas szintű programozási nyelvet.
        </para>
        <para>
            Ahoz, hogy a számítógép, valamint főként a processzor értelmezni tudja az általunk írt nyelvet, úgy mond le kell fordítanunk gépi nyelvre. Erre két fajta technika létezik:
            &#13;- fordítóprogramos
            &#13;- interpreteres
            
            A fordítóprogram egy magas szintű nyelvben megírt forrásprogramból, úgy nevezett tárgyprogramot állít elő, amely a következő lépéseket hajtja végre:
            &#13;- lexikális elemzés
            &#13;- szintaktikai elemzés
            &#13;- szemantikai elemzés
            &#13;- kódgenerálás
        </para>
    <para>
    Karakterkészlet: 
    </para>
    <para>
    A programok forráskódjának legkisebb alkotóelemei a karakterek. A karakterkészlet minden nyelvnél alapvető és nyelvenként különböző lehet. Ezekből összeállíthatünk bonyolultabb nyelvi elemeket (eljárásorientált nyelveknél):

    </para>
    <itemizedlist>
            <listitem><para>lexikális egységek</para></listitem>
            <listitem><para>szintaktikai egységek</para></listitem>
            <listitem><para>utasítások</para></listitem>
            <listitem><para>programegységek</para></listitem>
            <listitem><para>fordítási egységek</para></listitem>
            <listitem><para>program</para></listitem>
        </itemizedlist>
        <para>
        Minden nyelvben hasonló a karakterek katekorizálása:
        <itemizedlist>
            <listitem><para>betűk (az angol ABC 26 betűje)</para></listitem>
            <listitem><para>számjegyek</para></listitem>
            <listitem><para>egyéb karakterek (elhatároló jelek: (pl. [, ],
., :, {, }, ’, ", ;), műveleti jelek : (+-*/),írásjelek : (?!) stb.)</para></listitem>
        </itemizedlist>
        </para>
        <para>
    Lexikális egységek:
        </para>
    <para>
    A program szövegének azon elemei, melyeket a fordító a lexikális elemzés során felismer,tokenizál,
    fajtái a következők:
    </para>
    <itemizedlist>
            <listitem><para>többkarakteres szimbólum</para></listitem>
            <listitem><para>szimbolikus név</para></listitem>
            <listitem><para>címke</para></listitem>
            <listitem><para>megjegyzés</para></listitem>
            <listitem><para>literál</para></listitem>
        </itemizedlist>
    </section>        
    <section>
        <title>C programozás bevezetés</title>
        <para>                
            Rövid olvasónapló a <citation>KERNIGHANRITCHIE</citation> könyvről.
        </para>
        <para>
            2. fejezet:

            &#13;A 2. fejezetben a típusokról, változókról,állandókról olvashatunk. Adattípusok:char,int,float,double. Az int típus long, long long, short előtagjáról is szó esik.
            Megemlíti az unsigned változók használatát is. Olvashatunk továbbá a '\' operátor felhasználásával alkozott állandókrol.

            A deklarációk pontos szintaktikájáról folyamatáról, aritmetikai operátorok (+-*/%) sajátosságairól, logikai operátorok használatáról, típuskonverzióról(castolás), in-dekrementáló operátorokról, maszkoláshoz használatos bitművelet operátorokról, értékadó operátorokról, feltételekról, precedenciákról is többet tudhatunk meg.

            &#13;3. fejezet:

            &#13;Tartalma a vezérlési szerkezetek:
            <itemizedlist>
            <listitem><para>Utasítások ( ; jelentőssége, {})</para></listitem>
            <listitem><para>if,else utasítás</para></listitem>
            <listitem><para>if,else if használata</para></listitem>
            <listitem><para>switch utasítás</para></listitem>
            <listitem><para>ciklusok (for,while,do-while)</para></listitem>
            <listitem><para>break, continue utasítások</para></listitem>
        </itemizedlist>
            &#13;4. fejezet:

            &#13;Tartalma a függvényes és a program szerkezete:
            <itemizedlist>
            <listitem><para>Függvények alapfogalmai:paraméter,visszatérési érték..</para></listitem>
            <listitem><para>Különböző, nem egésszel visszatérő függvények</para></listitem>
            <listitem><para>Külső változók</para></listitem>
            <listitem><para>Érvényességi tartomány</para></listitem>
            <listitem><para>Header file-ok</para></listitem>
            <listitem><para>static használata(függvény saját érték esetén)</para></listitem>
            <listitem><para>register használata(gyakran használt változó)</para></listitem>
            <listitem><para>Rekurzió függvényekben</para></listitem>
            <listitem><para>C előfeldolgozás(#include,#define)</para></listitem>
            <listitem><para>Makrók,feltételes fordítás</para></listitem>
        </itemizedlist>

        </para>      
    </section>        
    <section>
        <title>C++ programozás</title>
        <para>
            Ez a fejezet főként a C++, C-hez mért változásairól és úgy amblokk a C++-alap fogalmairól és újdonságairól. A fejezet kódcsipeteit csak c++ fordítóval tudjuk fordítani.
            Első különbség a C-től eltérően a c++-ban egy függvény üres paraméterlistáját (void)-al jelöljük, míg a C-ben csak üresen kellet hagyni. Ha tetszőleges számú paramétert akarunk megadni akkor a (...) szintaktikát kell alkalmaznunk. Visszatérési típusoknál a következő a helyzet a C-t és a C++-t illetően: az f(){ //függvénytörzs } függvény C-ben int típussal térne vissza, azonban C++-ban hibát kapunk, mert itt már nincs lehetőségünk
            visszatérési típus nélküli fuggvény deklarálnunk. C++ main függvénye kétféle képpen deklarálható : argc,argv argumentumokkal, vagy azok nélkül. Érdekesség, hogy nincs szükség a return 0;-ra, mert sikeres futás esetén a 
            main függvényünk alapvetően 0-val tér vissza. Meg kell említenünk mint ultimate feature-t : bool típus! A C-ben nem használhatunk bool típust, azonban a C++-ban már megtehetjük ezt. A bool azaz boolean típusú változó, igaz, vagy hamis értékkel inicializálható. Létezik automatikus konverzió az int és a bool között : 0-false 1-true. Változódeklaráció, mint utasítás : ami azt jelenti, hogy bárhol állhat változó, ahol állhat utasítás. Ez lehetővé teszi, hogy akár ideiglenes változót akkor deklaráljunk amikor szügség van rá, így az általa lefoglalt memória nem lesz felhasználva, ameddig arra feltétlen szükségünk nincsen.
        </para>
    </section>        
    <section>
        <title>Python nyelvi bevezetés</title>
        <para>                
            A Python nyelvi sajátosságai, további saját kiegészítések :

        </para>
        <itemizedlist>
            <listitem><para>Deklaráció során nincs típus deklaráció.</para></listitem>
            <listitem><para>A for ciklus szintaktikája teljesen más. A C# foreach-hez hasonló.</para></listitem>
            <listitem><para>Szintaktia, kódcsoportosítás egyszerű tagolással:( "{ }", ";" nincsenek kódcsoportosításra.Helyette space,kettőspont, tab.)</para></listitem>
            <listitem><para>A Python interpreter használ.</para></listitem>
            <listitem><para>Az állításokat azonos szintű behúzásokkal tudjuk csoportosítani.</para></listitem>
            <listitem><para>Komment : '#'</para></listitem>
            <listitem><para>Az if-else, ciklusok,függvények deklarációja után közvetlen : -ot használunk</para></listitem>
            <listitem><para>Nincs típus -&gt; nincs függvény visszatérési érték deklaráció sem.</para></listitem>
        </itemizedlist>
    </section>        
</chapter>     
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>  

    <section>
        <title>Olvasónapló:</title>
        <para>
            <!-- 
                TODO:
                c++
                java vs c++
                python
            -->
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>A BPP algoritmus Java megvalósítása</title>
        <para>
            Ez már a Prog2, de előre dolgozhatsz a nyári szünetben!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://regi.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html">https://regi.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html</link>               
        </para>
    </section>        

    <section>
        <title>Java osztályok a Pi-ben</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>

    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter> 
             
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
        <biblioentry xml:lang="hu">
            <abbrev>PICI</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>István</firstname>
                        <surname>Juhász</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Magas szintű programozási nyelvek I.</title>
        </biblioentry>  
        <biblioentry xml:lang="en">
            <abbrev>SMNIST</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Norbert</firstname>
                        <surname>Bátfai</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dávid</firstname>
                        <surname>Papp</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Gergő</firstname>
                        <surname>Bogacsovics</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Máté</firstname>
                        <surname>Szabó</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Viktor Szilárd</firstname>
                        <surname>Simkó</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Márió</firstname>
                        <surname>Bersenszki</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Gergely</firstname>
                        <surname>Szabó</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Lajos</firstname>
                        <surname>Kovács</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Ferencz</firstname>
                        <surname>Kovács</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Erik Szilveszter</firstname>
                        <surname>Varga</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Object file system software experiments about the notion of number in humans and machines</title>
            <publisher>
                <publishername>
                    Cognition, Brain, Behavior. An Interdisciplinary Journal
                </publishername>
            </publisher>
            <biblioid class="doi">
                 10.24193/cbb.2019.23.15
            </biblioid>
            <pubdate>2019</pubdate>
        </biblioentry>          
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry xml:lang="hu">
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry xml:lang="hu">
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Python</title>
        <biblioentry xml:lang="hu">
            <abbrev>BMEPY</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Péter</firstname>
                        <surname>Ekler</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Bertalan</firstname>
                        <surname>Forstner</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Imre</firstname>
                        <surname>Kelényi</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Bevezetés a mobilprogramozásba - Gyors prototípusfejlesztés Python és Java nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2008</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
    <para>
        A tananyag elkészítését az EFOP-3.4.3-16-2016-00021 számú projekt támogatta. A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszírozásával valósult meg.        
    </para>                     
</acknowledgements>   
        
        <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
    <para>
        A tananyag elkészítését az EFOP-3.4.3-16-2016-00021 számú projekt támogatta. A projekt az Európai Unió támogatásával, az Európai Szociális Alap társfinanszírozásával valósult meg.        
    </para>                     
</acknowledgements>  

</book>
